Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSE
    IF
    NAME
    WHILE

Grammar

Rule 0     S' -> line
Rule 1     line -> statement SEMICOLON
Rule 2     statement -> ID EQUALS expression
Rule 3     statement -> declaration EQUALS expression
Rule 4     statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
Rule 5     statement -> type ID LPAREN args RPAREN LBRACKET body RBRACKET
Rule 6     declaration -> type ID
Rule 7     body -> line body
Rule 8     body -> empty
Rule 9     args -> declaration COMMA args
Rule 10    args -> declaration
Rule 11    args -> empty
Rule 12    statement -> RETURN ID
Rule 13    statement -> RETURN NUMBER
Rule 14    expression -> expression PLUS expression
Rule 15    expression -> expression MINUS expression
Rule 16    expression -> expression TIMES expression
Rule 17    expression -> expression DIVIDE expression
Rule 18    expression -> MINUS expression
Rule 19    expression -> LPAREN expression RPAREN
Rule 20    expression -> NUMBER
Rule 21    type -> INT
Rule 22    type -> FLOAT
Rule 23    type -> DOUBLE
Rule 24    type -> CHAR
Rule 25    empty -> <empty>

Terminals, with rules where they appear

CHAR                 : 24
COMMA                : 9
DIVIDE               : 17
DOUBLE               : 23
ELSE                 : 
EQUALS               : 2 3
FLOAT                : 22
ID                   : 2 4 5 6 12
IF                   : 
INT                  : 21
LBRACKET             : 4 5
LPAREN               : 4 5 19
MINUS                : 15 18
NAME                 : 
NUMBER               : 13 20
PLUS                 : 14
RBRACKET             : 4 5
RETURN               : 12 13
RPAREN               : 4 5 19
SEMICOLON            : 1
TIMES                : 16
VOID                 : 4
WHILE                : 
error                : 

Nonterminals, with rules where they appear

args                 : 4 5 9
body                 : 4 5 7
declaration          : 3 9 10
empty                : 8 11
expression           : 2 3 14 14 15 15 16 16 17 17 18 19
line                 : 7 0
statement            : 1
type                 : 5 6

Parsing method: LALR

state 0

    (0) S' -> . line
    (1) line -> . statement SEMICOLON
    (2) statement -> . ID EQUALS expression
    (3) statement -> . declaration EQUALS expression
    (4) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (5) statement -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (12) statement -> . RETURN ID
    (13) statement -> . RETURN NUMBER
    (6) declaration -> . type ID
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    ID              shift and go to state 3
    VOID            shift and go to state 5
    RETURN          shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    line                           shift and go to state 1
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    type                           shift and go to state 6

state 1

    (0) S' -> line .



state 2

    (1) line -> statement . SEMICOLON

    SEMICOLON       shift and go to state 12


state 3

    (2) statement -> ID . EQUALS expression

    EQUALS          shift and go to state 13


state 4

    (3) statement -> declaration . EQUALS expression

    EQUALS          shift and go to state 14


state 5

    (4) statement -> VOID . ID LPAREN args RPAREN LBRACKET body RBRACKET

    ID              shift and go to state 15


state 6

    (5) statement -> type . ID LPAREN args RPAREN LBRACKET body RBRACKET
    (6) declaration -> type . ID

    ID              shift and go to state 16


state 7

    (12) statement -> RETURN . ID
    (13) statement -> RETURN . NUMBER

    ID              shift and go to state 17
    NUMBER          shift and go to state 18


state 8

    (21) type -> INT .

    ID              reduce using rule 21 (type -> INT .)


state 9

    (22) type -> FLOAT .

    ID              reduce using rule 22 (type -> FLOAT .)


state 10

    (23) type -> DOUBLE .

    ID              reduce using rule 23 (type -> DOUBLE .)


state 11

    (24) type -> CHAR .

    ID              reduce using rule 24 (type -> CHAR .)


state 12

    (1) line -> statement SEMICOLON .

    $end            reduce using rule 1 (line -> statement SEMICOLON .)
    ID              reduce using rule 1 (line -> statement SEMICOLON .)
    VOID            reduce using rule 1 (line -> statement SEMICOLON .)
    RETURN          reduce using rule 1 (line -> statement SEMICOLON .)
    INT             reduce using rule 1 (line -> statement SEMICOLON .)
    FLOAT           reduce using rule 1 (line -> statement SEMICOLON .)
    DOUBLE          reduce using rule 1 (line -> statement SEMICOLON .)
    CHAR            reduce using rule 1 (line -> statement SEMICOLON .)
    RBRACKET        reduce using rule 1 (line -> statement SEMICOLON .)


state 13

    (2) statement -> ID EQUALS . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 19

state 14

    (3) statement -> declaration EQUALS . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 23

state 15

    (4) statement -> VOID ID . LPAREN args RPAREN LBRACKET body RBRACKET

    LPAREN          shift and go to state 24


state 16

    (5) statement -> type ID . LPAREN args RPAREN LBRACKET body RBRACKET
    (6) declaration -> type ID .

    LPAREN          shift and go to state 25
    EQUALS          reduce using rule 6 (declaration -> type ID .)


state 17

    (12) statement -> RETURN ID .

    SEMICOLON       reduce using rule 12 (statement -> RETURN ID .)


state 18

    (13) statement -> RETURN NUMBER .

    SEMICOLON       reduce using rule 13 (statement -> RETURN NUMBER .)


state 19

    (2) statement -> ID EQUALS expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 2 (statement -> ID EQUALS expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29


state 20

    (18) expression -> MINUS . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 30

state 21

    (19) expression -> LPAREN . expression RPAREN
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 31

state 22

    (20) expression -> NUMBER .

    PLUS            reduce using rule 20 (expression -> NUMBER .)
    MINUS           reduce using rule 20 (expression -> NUMBER .)
    TIMES           reduce using rule 20 (expression -> NUMBER .)
    DIVIDE          reduce using rule 20 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 20 (expression -> NUMBER .)
    RPAREN          reduce using rule 20 (expression -> NUMBER .)


state 23

    (3) statement -> declaration EQUALS expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 3 (statement -> declaration EQUALS expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29


state 24

    (4) statement -> VOID ID LPAREN . args RPAREN LBRACKET body RBRACKET
    (9) args -> . declaration COMMA args
    (10) args -> . declaration
    (11) args -> . empty
    (6) declaration -> . type ID
    (25) empty -> .
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RPAREN          reduce using rule 25 (empty -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    args                           shift and go to state 32
    declaration                    shift and go to state 33
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 25

    (5) statement -> type ID LPAREN . args RPAREN LBRACKET body RBRACKET
    (9) args -> . declaration COMMA args
    (10) args -> . declaration
    (11) args -> . empty
    (6) declaration -> . type ID
    (25) empty -> .
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RPAREN          reduce using rule 25 (empty -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    type                           shift and go to state 35
    args                           shift and go to state 36
    declaration                    shift and go to state 33
    empty                          shift and go to state 34

state 26

    (14) expression -> expression PLUS . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 37

state 27

    (15) expression -> expression MINUS . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 38

state 28

    (16) expression -> expression TIMES . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 39

state 29

    (17) expression -> expression DIVIDE . expression
    (14) expression -> . expression PLUS expression
    (15) expression -> . expression MINUS expression
    (16) expression -> . expression TIMES expression
    (17) expression -> . expression DIVIDE expression
    (18) expression -> . MINUS expression
    (19) expression -> . LPAREN expression RPAREN
    (20) expression -> . NUMBER

    MINUS           shift and go to state 20
    LPAREN          shift and go to state 21
    NUMBER          shift and go to state 22

    expression                     shift and go to state 40

state 30

    (18) expression -> MINUS expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 18 (expression -> MINUS expression .)
    MINUS           reduce using rule 18 (expression -> MINUS expression .)
    TIMES           reduce using rule 18 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 18 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 18 (expression -> MINUS expression .)
    RPAREN          reduce using rule 18 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! TIMES           [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]


state 31

    (19) expression -> LPAREN expression . RPAREN
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 41
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29


state 32

    (4) statement -> VOID ID LPAREN args . RPAREN LBRACKET body RBRACKET

    RPAREN          shift and go to state 42


state 33

    (9) args -> declaration . COMMA args
    (10) args -> declaration .

    COMMA           shift and go to state 43
    RPAREN          reduce using rule 10 (args -> declaration .)


state 34

    (11) args -> empty .

    RPAREN          reduce using rule 11 (args -> empty .)


state 35

    (6) declaration -> type . ID

    ID              shift and go to state 44


state 36

    (5) statement -> type ID LPAREN args . RPAREN LBRACKET body RBRACKET

    RPAREN          shift and go to state 45


state 37

    (14) expression -> expression PLUS expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 14 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 14 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 14 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 14 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29

  ! TIMES           [ reduce using rule 14 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 14 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]


state 38

    (15) expression -> expression MINUS expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 15 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 15 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 15 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 15 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29

  ! TIMES           [ reduce using rule 15 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 15 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]


state 39

    (16) expression -> expression TIMES expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 16 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 16 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 16 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 16 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 16 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 16 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! TIMES           [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]


state 40

    (17) expression -> expression DIVIDE expression .
    (14) expression -> expression . PLUS expression
    (15) expression -> expression . MINUS expression
    (16) expression -> expression . TIMES expression
    (17) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 17 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 17 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 17 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 17 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 17 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 17 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 27 ]
  ! TIMES           [ shift and go to state 28 ]
  ! DIVIDE          [ shift and go to state 29 ]


state 41

    (19) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 19 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 19 (expression -> LPAREN expression RPAREN .)


state 42

    (4) statement -> VOID ID LPAREN args RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 46


state 43

    (9) args -> declaration COMMA . args
    (9) args -> . declaration COMMA args
    (10) args -> . declaration
    (11) args -> . empty
    (6) declaration -> . type ID
    (25) empty -> .
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RPAREN          reduce using rule 25 (empty -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    declaration                    shift and go to state 33
    args                           shift and go to state 47
    empty                          shift and go to state 34
    type                           shift and go to state 35

state 44

    (6) declaration -> type ID .

    COMMA           reduce using rule 6 (declaration -> type ID .)
    RPAREN          reduce using rule 6 (declaration -> type ID .)


state 45

    (5) statement -> type ID LPAREN args RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 48


state 46

    (4) statement -> VOID ID LPAREN args RPAREN LBRACKET . body RBRACKET
    (7) body -> . line body
    (8) body -> . empty
    (1) line -> . statement SEMICOLON
    (25) empty -> .
    (2) statement -> . ID EQUALS expression
    (3) statement -> . declaration EQUALS expression
    (4) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (5) statement -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (12) statement -> . RETURN ID
    (13) statement -> . RETURN NUMBER
    (6) declaration -> . type ID
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RBRACKET        reduce using rule 25 (empty -> .)
    ID              shift and go to state 3
    VOID            shift and go to state 5
    RETURN          shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    body                           shift and go to state 49
    line                           shift and go to state 50
    empty                          shift and go to state 51
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    type                           shift and go to state 6

state 47

    (9) args -> declaration COMMA args .

    RPAREN          reduce using rule 9 (args -> declaration COMMA args .)


state 48

    (5) statement -> type ID LPAREN args RPAREN LBRACKET . body RBRACKET
    (7) body -> . line body
    (8) body -> . empty
    (1) line -> . statement SEMICOLON
    (25) empty -> .
    (2) statement -> . ID EQUALS expression
    (3) statement -> . declaration EQUALS expression
    (4) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (5) statement -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (12) statement -> . RETURN ID
    (13) statement -> . RETURN NUMBER
    (6) declaration -> . type ID
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RBRACKET        reduce using rule 25 (empty -> .)
    ID              shift and go to state 3
    VOID            shift and go to state 5
    RETURN          shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    type                           shift and go to state 6
    body                           shift and go to state 52
    line                           shift and go to state 50
    empty                          shift and go to state 51
    statement                      shift and go to state 2
    declaration                    shift and go to state 4

state 49

    (4) statement -> VOID ID LPAREN args RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 53


state 50

    (7) body -> line . body
    (7) body -> . line body
    (8) body -> . empty
    (1) line -> . statement SEMICOLON
    (25) empty -> .
    (2) statement -> . ID EQUALS expression
    (3) statement -> . declaration EQUALS expression
    (4) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (5) statement -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (12) statement -> . RETURN ID
    (13) statement -> . RETURN NUMBER
    (6) declaration -> . type ID
    (21) type -> . INT
    (22) type -> . FLOAT
    (23) type -> . DOUBLE
    (24) type -> . CHAR

    RBRACKET        reduce using rule 25 (empty -> .)
    ID              shift and go to state 3
    VOID            shift and go to state 5
    RETURN          shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    DOUBLE          shift and go to state 10
    CHAR            shift and go to state 11

    line                           shift and go to state 50
    body                           shift and go to state 54
    empty                          shift and go to state 51
    statement                      shift and go to state 2
    declaration                    shift and go to state 4
    type                           shift and go to state 6

state 51

    (8) body -> empty .

    RBRACKET        reduce using rule 8 (body -> empty .)


state 52

    (5) statement -> type ID LPAREN args RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 55


state 53

    (4) statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET .

    SEMICOLON       reduce using rule 4 (statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET .)


state 54

    (7) body -> line body .

    RBRACKET        reduce using rule 7 (body -> line body .)


state 55

    (5) statement -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .

    SEMICOLON       reduce using rule 5 (statement -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)


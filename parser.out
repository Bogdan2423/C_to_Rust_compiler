Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> function_declaration program
Rule 2     program -> empty
Rule 3     line -> statement SEMICOLON
Rule 4     line -> expression SEMICOLON
Rule 5     line -> loop_statement
Rule 6     line -> if_statement
Rule 7     statement -> ID EQUALS expression
Rule 8     statement -> declaration EQUALS expression
Rule 9     statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
Rule 10    function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET
Rule 11    declaration -> type ID
Rule 12    body -> line body
Rule 13    body -> empty
Rule 14    if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
Rule 15    if_statement -> IF LPAREN expression RPAREN line else_statement
Rule 16    else_statement -> ELSE LBRACKET body RBRACKET
Rule 17    else_statement -> ELSE line
Rule 18    else_statement -> empty
Rule 19    loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
Rule 20    loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
Rule 21    args -> declaration COMMA args
Rule 22    args -> declaration
Rule 23    args -> empty
Rule 24    function_args -> ID COMMA function_args
Rule 25    function_args -> ID
Rule 26    function_args -> empty
Rule 27    statement -> RETURN ID
Rule 28    statement -> RETURN expression
Rule 29    expression -> ID LPAREN function_args RPAREN
Rule 30    expression -> expression EQUALS EQUALS expression
Rule 31    expression -> expression PLUS expression
Rule 32    expression -> expression MINUS expression
Rule 33    expression -> expression TIMES expression
Rule 34    expression -> expression DIVIDE expression
Rule 35    expression -> MINUS expression
Rule 36    expression -> LPAREN expression RPAREN
Rule 37    expression -> NUMBER
Rule 38    expression -> ID
Rule 39    type -> INT
Rule 40    type -> FLOAT
Rule 41    type -> DOUBLE
Rule 42    type -> CHAR
Rule 43    empty -> <empty>

Terminals, with rules where they appear

CHAR                 : 42
COMMA                : 21 24
DIVIDE               : 34
DOUBLE               : 41
ELSE                 : 16 17
EQUALS               : 7 8 30 30
FLOAT                : 40
FOR                  : 20
ID                   : 7 9 10 11 24 25 27 29 38
IF                   : 14 15
INT                  : 39
LBRACKET             : 9 10 14 16 19 20
LPAREN               : 9 10 14 15 19 20 29 36
MINUS                : 32 35
NUMBER               : 37
PLUS                 : 31
RBRACKET             : 9 10 14 16 19 20
RETURN               : 27 28
RPAREN               : 9 10 14 15 19 20 29 36
SEMICOLON            : 3 4 20 20
TIMES                : 33
VOID                 : 9
WHILE                : 19
error                : 

Nonterminals, with rules where they appear

args                 : 9 10 21
body                 : 9 10 12 14 16 19 20
declaration          : 8 21 22
else_statement       : 14 15
empty                : 2 13 18 23 26
expression           : 4 7 8 14 15 19 20 28 30 30 31 31 32 32 33 33 34 34 35 36
function_args        : 24 29
function_declaration : 1
if_statement         : 6
line                 : 12 15 17
loop_statement       : 5
program              : 1 0
statement            : 3 20 20
type                 : 10 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function_declaration program
    (2) program -> . empty
    (10) function_declaration -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (43) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    $end            reduce using rule 43 (empty -> .)
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    program                        shift and go to state 1
    function_declaration           shift and go to state 2
    empty                          shift and go to state 3
    type                           shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> function_declaration . program
    (1) program -> . function_declaration program
    (2) program -> . empty
    (10) function_declaration -> . type ID LPAREN args RPAREN LBRACKET body RBRACKET
    (43) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    $end            reduce using rule 43 (empty -> .)
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    function_declaration           shift and go to state 2
    program                        shift and go to state 9
    empty                          shift and go to state 3
    type                           shift and go to state 4

state 3

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 4

    (10) function_declaration -> type . ID LPAREN args RPAREN LBRACKET body RBRACKET

    ID              shift and go to state 10


state 5

    (39) type -> INT .

    ID              reduce using rule 39 (type -> INT .)


state 6

    (40) type -> FLOAT .

    ID              reduce using rule 40 (type -> FLOAT .)


state 7

    (41) type -> DOUBLE .

    ID              reduce using rule 41 (type -> DOUBLE .)


state 8

    (42) type -> CHAR .

    ID              reduce using rule 42 (type -> CHAR .)


state 9

    (1) program -> function_declaration program .

    $end            reduce using rule 1 (program -> function_declaration program .)


state 10

    (10) function_declaration -> type ID . LPAREN args RPAREN LBRACKET body RBRACKET

    LPAREN          shift and go to state 11


state 11

    (10) function_declaration -> type ID LPAREN . args RPAREN LBRACKET body RBRACKET
    (21) args -> . declaration COMMA args
    (22) args -> . declaration
    (23) args -> . empty
    (11) declaration -> . type ID
    (43) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RPAREN          reduce using rule 43 (empty -> .)
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    type                           shift and go to state 12
    args                           shift and go to state 13
    declaration                    shift and go to state 14
    empty                          shift and go to state 15

state 12

    (11) declaration -> type . ID

    ID              shift and go to state 16


state 13

    (10) function_declaration -> type ID LPAREN args . RPAREN LBRACKET body RBRACKET

    RPAREN          shift and go to state 17


state 14

    (21) args -> declaration . COMMA args
    (22) args -> declaration .

    COMMA           shift and go to state 18
    RPAREN          reduce using rule 22 (args -> declaration .)


state 15

    (23) args -> empty .

    RPAREN          reduce using rule 23 (args -> empty .)


state 16

    (11) declaration -> type ID .

    COMMA           reduce using rule 11 (declaration -> type ID .)
    RPAREN          reduce using rule 11 (declaration -> type ID .)
    EQUALS          reduce using rule 11 (declaration -> type ID .)


state 17

    (10) function_declaration -> type ID LPAREN args RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 19


state 18

    (21) args -> declaration COMMA . args
    (21) args -> . declaration COMMA args
    (22) args -> . declaration
    (23) args -> . empty
    (11) declaration -> . type ID
    (43) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RPAREN          reduce using rule 43 (empty -> .)
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    declaration                    shift and go to state 14
    args                           shift and go to state 20
    empty                          shift and go to state 15
    type                           shift and go to state 12

state 19

    (10) function_declaration -> type ID LPAREN args RPAREN LBRACKET . body RBRACKET
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    type                           shift and go to state 12
    body                           shift and go to state 23
    line                           shift and go to state 24
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    expression                     shift and go to state 27
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30

state 20

    (21) args -> declaration COMMA args .

    RPAREN          reduce using rule 21 (args -> declaration COMMA args .)


state 21

    (7) statement -> ID . EQUALS expression
    (29) expression -> ID . LPAREN function_args RPAREN
    (38) expression -> ID .

  ! shift/reduce conflict for EQUALS resolved as shift
    EQUALS          shift and go to state 38
    LPAREN          shift and go to state 39
    SEMICOLON       reduce using rule 38 (expression -> ID .)
    PLUS            reduce using rule 38 (expression -> ID .)
    MINUS           reduce using rule 38 (expression -> ID .)
    TIMES           reduce using rule 38 (expression -> ID .)
    DIVIDE          reduce using rule 38 (expression -> ID .)

  ! EQUALS          [ reduce using rule 38 (expression -> ID .) ]


state 22

    (36) expression -> LPAREN . expression RPAREN
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 40

state 23

    (10) function_declaration -> type ID LPAREN args RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 42


state 24

    (12) body -> line . body
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    line                           shift and go to state 24
    body                           shift and go to state 43
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    expression                     shift and go to state 27
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 25

    (13) body -> empty .

    RBRACKET        reduce using rule 13 (body -> empty .)


state 26

    (3) line -> statement . SEMICOLON

    SEMICOLON       shift and go to state 44


state 27

    (4) line -> expression . SEMICOLON
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 45
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 28

    (5) line -> loop_statement .

    ID              reduce using rule 5 (line -> loop_statement .)
    VOID            reduce using rule 5 (line -> loop_statement .)
    RETURN          reduce using rule 5 (line -> loop_statement .)
    MINUS           reduce using rule 5 (line -> loop_statement .)
    LPAREN          reduce using rule 5 (line -> loop_statement .)
    NUMBER          reduce using rule 5 (line -> loop_statement .)
    WHILE           reduce using rule 5 (line -> loop_statement .)
    FOR             reduce using rule 5 (line -> loop_statement .)
    IF              reduce using rule 5 (line -> loop_statement .)
    INT             reduce using rule 5 (line -> loop_statement .)
    FLOAT           reduce using rule 5 (line -> loop_statement .)
    DOUBLE          reduce using rule 5 (line -> loop_statement .)
    CHAR            reduce using rule 5 (line -> loop_statement .)
    RBRACKET        reduce using rule 5 (line -> loop_statement .)
    ELSE            reduce using rule 5 (line -> loop_statement .)


state 29

    (6) line -> if_statement .

    ID              reduce using rule 6 (line -> if_statement .)
    VOID            reduce using rule 6 (line -> if_statement .)
    RETURN          reduce using rule 6 (line -> if_statement .)
    MINUS           reduce using rule 6 (line -> if_statement .)
    LPAREN          reduce using rule 6 (line -> if_statement .)
    NUMBER          reduce using rule 6 (line -> if_statement .)
    WHILE           reduce using rule 6 (line -> if_statement .)
    FOR             reduce using rule 6 (line -> if_statement .)
    IF              reduce using rule 6 (line -> if_statement .)
    INT             reduce using rule 6 (line -> if_statement .)
    FLOAT           reduce using rule 6 (line -> if_statement .)
    DOUBLE          reduce using rule 6 (line -> if_statement .)
    CHAR            reduce using rule 6 (line -> if_statement .)
    RBRACKET        reduce using rule 6 (line -> if_statement .)
    ELSE            reduce using rule 6 (line -> if_statement .)


state 30

    (8) statement -> declaration . EQUALS expression

    EQUALS          shift and go to state 51


state 31

    (9) statement -> VOID . ID LPAREN args RPAREN LBRACKET body RBRACKET

    ID              shift and go to state 52


state 32

    (27) statement -> RETURN . ID
    (28) statement -> RETURN . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 53
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 54

state 33

    (35) expression -> MINUS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 55

state 34

    (37) expression -> NUMBER .

    SEMICOLON       reduce using rule 37 (expression -> NUMBER .)
    EQUALS          reduce using rule 37 (expression -> NUMBER .)
    PLUS            reduce using rule 37 (expression -> NUMBER .)
    MINUS           reduce using rule 37 (expression -> NUMBER .)
    TIMES           reduce using rule 37 (expression -> NUMBER .)
    DIVIDE          reduce using rule 37 (expression -> NUMBER .)
    RPAREN          reduce using rule 37 (expression -> NUMBER .)


state 35

    (19) loop_statement -> WHILE . LPAREN expression RPAREN LBRACKET body RBRACKET

    LPAREN          shift and go to state 56


state 36

    (20) loop_statement -> FOR . LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET

    LPAREN          shift and go to state 57


state 37

    (14) if_statement -> IF . LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> IF . LPAREN expression RPAREN line else_statement

    LPAREN          shift and go to state 58


state 38

    (7) statement -> ID EQUALS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 59

state 39

    (29) expression -> ID LPAREN . function_args RPAREN
    (24) function_args -> . ID COMMA function_args
    (25) function_args -> . ID
    (26) function_args -> . empty
    (43) empty -> .

    ID              shift and go to state 60
    RPAREN          reduce using rule 43 (empty -> .)

    function_args                  shift and go to state 61
    empty                          shift and go to state 62

state 40

    (36) expression -> LPAREN expression . RPAREN
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 63
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 41

    (29) expression -> ID . LPAREN function_args RPAREN
    (38) expression -> ID .

    LPAREN          shift and go to state 39
    RPAREN          reduce using rule 38 (expression -> ID .)
    EQUALS          reduce using rule 38 (expression -> ID .)
    PLUS            reduce using rule 38 (expression -> ID .)
    MINUS           reduce using rule 38 (expression -> ID .)
    TIMES           reduce using rule 38 (expression -> ID .)
    DIVIDE          reduce using rule 38 (expression -> ID .)
    SEMICOLON       reduce using rule 38 (expression -> ID .)


state 42

    (10) function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .

    INT             reduce using rule 10 (function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 10 (function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 10 (function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)
    CHAR            reduce using rule 10 (function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)
    $end            reduce using rule 10 (function_declaration -> type ID LPAREN args RPAREN LBRACKET body RBRACKET .)


state 43

    (12) body -> line body .

    RBRACKET        reduce using rule 12 (body -> line body .)


state 44

    (3) line -> statement SEMICOLON .

    ID              reduce using rule 3 (line -> statement SEMICOLON .)
    VOID            reduce using rule 3 (line -> statement SEMICOLON .)
    RETURN          reduce using rule 3 (line -> statement SEMICOLON .)
    MINUS           reduce using rule 3 (line -> statement SEMICOLON .)
    LPAREN          reduce using rule 3 (line -> statement SEMICOLON .)
    NUMBER          reduce using rule 3 (line -> statement SEMICOLON .)
    WHILE           reduce using rule 3 (line -> statement SEMICOLON .)
    FOR             reduce using rule 3 (line -> statement SEMICOLON .)
    IF              reduce using rule 3 (line -> statement SEMICOLON .)
    INT             reduce using rule 3 (line -> statement SEMICOLON .)
    FLOAT           reduce using rule 3 (line -> statement SEMICOLON .)
    DOUBLE          reduce using rule 3 (line -> statement SEMICOLON .)
    CHAR            reduce using rule 3 (line -> statement SEMICOLON .)
    RBRACKET        reduce using rule 3 (line -> statement SEMICOLON .)
    ELSE            reduce using rule 3 (line -> statement SEMICOLON .)


state 45

    (4) line -> expression SEMICOLON .

    ID              reduce using rule 4 (line -> expression SEMICOLON .)
    VOID            reduce using rule 4 (line -> expression SEMICOLON .)
    RETURN          reduce using rule 4 (line -> expression SEMICOLON .)
    MINUS           reduce using rule 4 (line -> expression SEMICOLON .)
    LPAREN          reduce using rule 4 (line -> expression SEMICOLON .)
    NUMBER          reduce using rule 4 (line -> expression SEMICOLON .)
    WHILE           reduce using rule 4 (line -> expression SEMICOLON .)
    FOR             reduce using rule 4 (line -> expression SEMICOLON .)
    IF              reduce using rule 4 (line -> expression SEMICOLON .)
    INT             reduce using rule 4 (line -> expression SEMICOLON .)
    FLOAT           reduce using rule 4 (line -> expression SEMICOLON .)
    DOUBLE          reduce using rule 4 (line -> expression SEMICOLON .)
    CHAR            reduce using rule 4 (line -> expression SEMICOLON .)
    RBRACKET        reduce using rule 4 (line -> expression SEMICOLON .)
    ELSE            reduce using rule 4 (line -> expression SEMICOLON .)


state 46

    (30) expression -> expression EQUALS . EQUALS expression

    EQUALS          shift and go to state 64


state 47

    (31) expression -> expression PLUS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 65

state 48

    (32) expression -> expression MINUS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 66

state 49

    (33) expression -> expression TIMES . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 67

state 50

    (34) expression -> expression DIVIDE . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 68

state 51

    (8) statement -> declaration EQUALS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 69

state 52

    (9) statement -> VOID ID . LPAREN args RPAREN LBRACKET body RBRACKET

    LPAREN          shift and go to state 70


state 53

    (27) statement -> RETURN ID .
    (29) expression -> ID . LPAREN function_args RPAREN
    (38) expression -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 27 (statement -> RETURN ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (statement -> RETURN ID .)
    SEMICOLON       reduce using rule 27 (statement -> RETURN ID .)
    RPAREN          reduce using rule 27 (statement -> RETURN ID .)
    LPAREN          shift and go to state 39
    EQUALS          reduce using rule 38 (expression -> ID .)
    PLUS            reduce using rule 38 (expression -> ID .)
    MINUS           reduce using rule 38 (expression -> ID .)
    TIMES           reduce using rule 38 (expression -> ID .)
    DIVIDE          reduce using rule 38 (expression -> ID .)

  ! SEMICOLON       [ reduce using rule 38 (expression -> ID .) ]
  ! RPAREN          [ reduce using rule 38 (expression -> ID .) ]


state 54

    (28) statement -> RETURN expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 28 (statement -> RETURN expression .)
    RPAREN          reduce using rule 28 (statement -> RETURN expression .)
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 55

    (35) expression -> MINUS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 35 (expression -> MINUS expression .)
    EQUALS          reduce using rule 35 (expression -> MINUS expression .)
    PLUS            reduce using rule 35 (expression -> MINUS expression .)
    MINUS           reduce using rule 35 (expression -> MINUS expression .)
    TIMES           reduce using rule 35 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 35 (expression -> MINUS expression .)
    RPAREN          reduce using rule 35 (expression -> MINUS expression .)

  ! EQUALS          [ shift and go to state 46 ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]
  ! TIMES           [ shift and go to state 49 ]
  ! DIVIDE          [ shift and go to state 50 ]


state 56

    (19) loop_statement -> WHILE LPAREN . expression RPAREN LBRACKET body RBRACKET
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 71

state 57

    (20) loop_statement -> FOR LPAREN . statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    ID              shift and go to state 73
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    statement                      shift and go to state 72
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 58

    (14) if_statement -> IF LPAREN . expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> IF LPAREN . expression RPAREN line else_statement
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 74

state 59

    (7) statement -> ID EQUALS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 7 (statement -> ID EQUALS expression .)
    RPAREN          reduce using rule 7 (statement -> ID EQUALS expression .)
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 60

    (24) function_args -> ID . COMMA function_args
    (25) function_args -> ID .

    COMMA           shift and go to state 75
    RPAREN          reduce using rule 25 (function_args -> ID .)


state 61

    (29) expression -> ID LPAREN function_args . RPAREN

    RPAREN          shift and go to state 76


state 62

    (26) function_args -> empty .

    RPAREN          reduce using rule 26 (function_args -> empty .)


state 63

    (36) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 36 (expression -> LPAREN expression RPAREN .)


state 64

    (30) expression -> expression EQUALS EQUALS . expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 77

state 65

    (31) expression -> expression PLUS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 31 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 31 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 31 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 31 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 31 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! TIMES           [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! EQUALS          [ shift and go to state 46 ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]


state 66

    (32) expression -> expression MINUS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 32 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 32 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 32 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 32 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! TIMES           [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! EQUALS          [ shift and go to state 46 ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]


state 67

    (33) expression -> expression TIMES expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 33 (expression -> expression TIMES expression .)
    EQUALS          reduce using rule 33 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 33 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 33 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 33 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 33 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 33 (expression -> expression TIMES expression .)

  ! EQUALS          [ shift and go to state 46 ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]
  ! TIMES           [ shift and go to state 49 ]
  ! DIVIDE          [ shift and go to state 50 ]


state 68

    (34) expression -> expression DIVIDE expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 34 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 34 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 34 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 34 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 34 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 34 (expression -> expression DIVIDE expression .)

  ! EQUALS          [ shift and go to state 46 ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]
  ! TIMES           [ shift and go to state 49 ]
  ! DIVIDE          [ shift and go to state 50 ]


state 69

    (8) statement -> declaration EQUALS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 8 (statement -> declaration EQUALS expression .)
    RPAREN          reduce using rule 8 (statement -> declaration EQUALS expression .)
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 70

    (9) statement -> VOID ID LPAREN . args RPAREN LBRACKET body RBRACKET
    (21) args -> . declaration COMMA args
    (22) args -> . declaration
    (23) args -> . empty
    (11) declaration -> . type ID
    (43) empty -> .
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RPAREN          reduce using rule 43 (empty -> .)
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    args                           shift and go to state 78
    declaration                    shift and go to state 14
    empty                          shift and go to state 15
    type                           shift and go to state 12

state 71

    (19) loop_statement -> WHILE LPAREN expression . RPAREN LBRACKET body RBRACKET
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 79
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 72

    (20) loop_statement -> FOR LPAREN statement . SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET

    SEMICOLON       shift and go to state 80


state 73

    (7) statement -> ID . EQUALS expression

    EQUALS          shift and go to state 38


state 74

    (14) if_statement -> IF LPAREN expression . RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> IF LPAREN expression . RPAREN line else_statement
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 81
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 75

    (24) function_args -> ID COMMA . function_args
    (24) function_args -> . ID COMMA function_args
    (25) function_args -> . ID
    (26) function_args -> . empty
    (43) empty -> .

    ID              shift and go to state 60
    RPAREN          reduce using rule 43 (empty -> .)

    function_args                  shift and go to state 82
    empty                          shift and go to state 62

state 76

    (29) expression -> ID LPAREN function_args RPAREN .

    SEMICOLON       reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    EQUALS          reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    PLUS            reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    MINUS           reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    TIMES           reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    DIVIDE          reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)
    RPAREN          reduce using rule 29 (expression -> ID LPAREN function_args RPAREN .)


state 77

    (30) expression -> expression EQUALS EQUALS expression .
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    SEMICOLON       reduce using rule 30 (expression -> expression EQUALS EQUALS expression .)
    RPAREN          reduce using rule 30 (expression -> expression EQUALS EQUALS expression .)
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50

  ! EQUALS          [ reduce using rule 30 (expression -> expression EQUALS EQUALS expression .) ]
  ! PLUS            [ reduce using rule 30 (expression -> expression EQUALS EQUALS expression .) ]
  ! MINUS           [ reduce using rule 30 (expression -> expression EQUALS EQUALS expression .) ]
  ! TIMES           [ reduce using rule 30 (expression -> expression EQUALS EQUALS expression .) ]
  ! DIVIDE          [ reduce using rule 30 (expression -> expression EQUALS EQUALS expression .) ]


state 78

    (9) statement -> VOID ID LPAREN args . RPAREN LBRACKET body RBRACKET

    RPAREN          shift and go to state 83


state 79

    (19) loop_statement -> WHILE LPAREN expression RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 84


state 80

    (20) loop_statement -> FOR LPAREN statement SEMICOLON . expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID

    ID              shift and go to state 41
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34

    expression                     shift and go to state 85

state 81

    (14) if_statement -> IF LPAREN expression RPAREN . LBRACKET body RBRACKET else_statement
    (15) if_statement -> IF LPAREN expression RPAREN . line else_statement
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    LBRACKET        shift and go to state 86
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    expression                     shift and go to state 27
    line                           shift and go to state 87
    statement                      shift and go to state 26
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 82

    (24) function_args -> ID COMMA function_args .

    RPAREN          reduce using rule 24 (function_args -> ID COMMA function_args .)


state 83

    (9) statement -> VOID ID LPAREN args RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 88


state 84

    (19) loop_statement -> WHILE LPAREN expression RPAREN LBRACKET . body RBRACKET
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    expression                     shift and go to state 27
    body                           shift and go to state 89
    line                           shift and go to state 24
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 85

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression . SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (30) expression -> expression . EQUALS EQUALS expression
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 90
    EQUALS          shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 86

    (14) if_statement -> IF LPAREN expression RPAREN LBRACKET . body RBRACKET else_statement
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    expression                     shift and go to state 27
    body                           shift and go to state 91
    line                           shift and go to state 24
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 87

    (15) if_statement -> IF LPAREN expression RPAREN line . else_statement
    (16) else_statement -> . ELSE LBRACKET body RBRACKET
    (17) else_statement -> . ELSE line
    (18) else_statement -> . empty
    (43) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 93
    ID              reduce using rule 43 (empty -> .)
    VOID            reduce using rule 43 (empty -> .)
    RETURN          reduce using rule 43 (empty -> .)
    MINUS           reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    WHILE           reduce using rule 43 (empty -> .)
    FOR             reduce using rule 43 (empty -> .)
    IF              reduce using rule 43 (empty -> .)
    INT             reduce using rule 43 (empty -> .)
    FLOAT           reduce using rule 43 (empty -> .)
    DOUBLE          reduce using rule 43 (empty -> .)
    CHAR            reduce using rule 43 (empty -> .)
    RBRACKET        reduce using rule 43 (empty -> .)

  ! ELSE            [ reduce using rule 43 (empty -> .) ]

    else_statement                 shift and go to state 92
    empty                          shift and go to state 94

state 88

    (9) statement -> VOID ID LPAREN args RPAREN LBRACKET . body RBRACKET
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    body                           shift and go to state 95
    line                           shift and go to state 24
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    expression                     shift and go to state 27
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 89

    (19) loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 96


state 90

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON . statement RPAREN LBRACKET body RBRACKET
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    ID              shift and go to state 73
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    statement                      shift and go to state 97
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 91

    (14) if_statement -> IF LPAREN expression RPAREN LBRACKET body . RBRACKET else_statement

    RBRACKET        shift and go to state 98


state 92

    (15) if_statement -> IF LPAREN expression RPAREN line else_statement .

    ID              reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    VOID            reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    RETURN          reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    MINUS           reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    LPAREN          reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    NUMBER          reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    WHILE           reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    FOR             reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    IF              reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    INT             reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    FLOAT           reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    DOUBLE          reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    CHAR            reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    RBRACKET        reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)
    ELSE            reduce using rule 15 (if_statement -> IF LPAREN expression RPAREN line else_statement .)


state 93

    (16) else_statement -> ELSE . LBRACKET body RBRACKET
    (17) else_statement -> ELSE . line
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    LBRACKET        shift and go to state 99
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    line                           shift and go to state 100
    statement                      shift and go to state 26
    expression                     shift and go to state 27
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 94

    (18) else_statement -> empty .

    ELSE            reduce using rule 18 (else_statement -> empty .)
    ID              reduce using rule 18 (else_statement -> empty .)
    VOID            reduce using rule 18 (else_statement -> empty .)
    RETURN          reduce using rule 18 (else_statement -> empty .)
    MINUS           reduce using rule 18 (else_statement -> empty .)
    LPAREN          reduce using rule 18 (else_statement -> empty .)
    NUMBER          reduce using rule 18 (else_statement -> empty .)
    WHILE           reduce using rule 18 (else_statement -> empty .)
    FOR             reduce using rule 18 (else_statement -> empty .)
    IF              reduce using rule 18 (else_statement -> empty .)
    INT             reduce using rule 18 (else_statement -> empty .)
    FLOAT           reduce using rule 18 (else_statement -> empty .)
    DOUBLE          reduce using rule 18 (else_statement -> empty .)
    CHAR            reduce using rule 18 (else_statement -> empty .)
    RBRACKET        reduce using rule 18 (else_statement -> empty .)


state 95

    (9) statement -> VOID ID LPAREN args RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 101


state 96

    (19) loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .

    ID              reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    VOID            reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    RETURN          reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    MINUS           reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    LPAREN          reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    NUMBER          reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    WHILE           reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    FOR             reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    IF              reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    INT             reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    CHAR            reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)
    ELSE            reduce using rule 19 (loop_statement -> WHILE LPAREN expression RPAREN LBRACKET body RBRACKET .)


state 97

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement . RPAREN LBRACKET body RBRACKET

    RPAREN          shift and go to state 102


state 98

    (14) if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET . else_statement
    (16) else_statement -> . ELSE LBRACKET body RBRACKET
    (17) else_statement -> . ELSE line
    (18) else_statement -> . empty
    (43) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 93
    ID              reduce using rule 43 (empty -> .)
    VOID            reduce using rule 43 (empty -> .)
    RETURN          reduce using rule 43 (empty -> .)
    MINUS           reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    WHILE           reduce using rule 43 (empty -> .)
    FOR             reduce using rule 43 (empty -> .)
    IF              reduce using rule 43 (empty -> .)
    INT             reduce using rule 43 (empty -> .)
    FLOAT           reduce using rule 43 (empty -> .)
    DOUBLE          reduce using rule 43 (empty -> .)
    CHAR            reduce using rule 43 (empty -> .)
    RBRACKET        reduce using rule 43 (empty -> .)

  ! ELSE            [ reduce using rule 43 (empty -> .) ]

    else_statement                 shift and go to state 103
    empty                          shift and go to state 94

state 99

    (16) else_statement -> ELSE LBRACKET . body RBRACKET
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    body                           shift and go to state 104
    line                           shift and go to state 24
    empty                          shift and go to state 25
    statement                      shift and go to state 26
    expression                     shift and go to state 27
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 100

    (17) else_statement -> ELSE line .

    ELSE            reduce using rule 17 (else_statement -> ELSE line .)
    ID              reduce using rule 17 (else_statement -> ELSE line .)
    VOID            reduce using rule 17 (else_statement -> ELSE line .)
    RETURN          reduce using rule 17 (else_statement -> ELSE line .)
    MINUS           reduce using rule 17 (else_statement -> ELSE line .)
    LPAREN          reduce using rule 17 (else_statement -> ELSE line .)
    NUMBER          reduce using rule 17 (else_statement -> ELSE line .)
    WHILE           reduce using rule 17 (else_statement -> ELSE line .)
    FOR             reduce using rule 17 (else_statement -> ELSE line .)
    IF              reduce using rule 17 (else_statement -> ELSE line .)
    INT             reduce using rule 17 (else_statement -> ELSE line .)
    FLOAT           reduce using rule 17 (else_statement -> ELSE line .)
    DOUBLE          reduce using rule 17 (else_statement -> ELSE line .)
    CHAR            reduce using rule 17 (else_statement -> ELSE line .)
    RBRACKET        reduce using rule 17 (else_statement -> ELSE line .)


state 101

    (9) statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET .

    SEMICOLON       reduce using rule 9 (statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET .)
    RPAREN          reduce using rule 9 (statement -> VOID ID LPAREN args RPAREN LBRACKET body RBRACKET .)


state 102

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 105


state 103

    (14) if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .

    ID              reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    VOID            reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    RETURN          reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    MINUS           reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    LPAREN          reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    NUMBER          reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    WHILE           reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    FOR             reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    IF              reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    INT             reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    FLOAT           reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    DOUBLE          reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    CHAR            reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    RBRACKET        reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)
    ELSE            reduce using rule 14 (if_statement -> IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement .)


state 104

    (16) else_statement -> ELSE LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 106


state 105

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET . body RBRACKET
    (12) body -> . line body
    (13) body -> . empty
    (3) line -> . statement SEMICOLON
    (4) line -> . expression SEMICOLON
    (5) line -> . loop_statement
    (6) line -> . if_statement
    (43) empty -> .
    (7) statement -> . ID EQUALS expression
    (8) statement -> . declaration EQUALS expression
    (9) statement -> . VOID ID LPAREN args RPAREN LBRACKET body RBRACKET
    (27) statement -> . RETURN ID
    (28) statement -> . RETURN expression
    (29) expression -> . ID LPAREN function_args RPAREN
    (30) expression -> . expression EQUALS EQUALS expression
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . NUMBER
    (38) expression -> . ID
    (19) loop_statement -> . WHILE LPAREN expression RPAREN LBRACKET body RBRACKET
    (20) loop_statement -> . FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET
    (14) if_statement -> . IF LPAREN expression RPAREN LBRACKET body RBRACKET else_statement
    (15) if_statement -> . IF LPAREN expression RPAREN line else_statement
    (11) declaration -> . type ID
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . DOUBLE
    (42) type -> . CHAR

    RBRACKET        reduce using rule 43 (empty -> .)
    ID              shift and go to state 21
    VOID            shift and go to state 31
    RETURN          shift and go to state 32
    MINUS           shift and go to state 33
    LPAREN          shift and go to state 22
    NUMBER          shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    IF              shift and go to state 37
    INT             shift and go to state 5
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 7
    CHAR            shift and go to state 8

    statement                      shift and go to state 26
    expression                     shift and go to state 27
    body                           shift and go to state 107
    line                           shift and go to state 24
    empty                          shift and go to state 25
    loop_statement                 shift and go to state 28
    if_statement                   shift and go to state 29
    declaration                    shift and go to state 30
    type                           shift and go to state 12

state 106

    (16) else_statement -> ELSE LBRACKET body RBRACKET .

    ELSE            reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    ID              reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    VOID            reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    RETURN          reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    MINUS           reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    LPAREN          reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    NUMBER          reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    WHILE           reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    FOR             reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    IF              reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    INT             reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    CHAR            reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 16 (else_statement -> ELSE LBRACKET body RBRACKET .)


state 107

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 108


state 108

    (20) loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .

    ID              reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    VOID            reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    RETURN          reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    MINUS           reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    LPAREN          reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    NUMBER          reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    WHILE           reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    FOR             reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    IF              reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    INT             reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    CHAR            reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)
    ELSE            reduce using rule 20 (loop_statement -> FOR LPAREN statement SEMICOLON expression SEMICOLON statement RPAREN LBRACKET body RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUALS in state 21 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 87 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 98 resolved as shift
WARNING: reduce/reduce conflict in state 53 resolved using rule (statement -> RETURN ID)
WARNING: rejected rule (expression -> ID) in state 53
